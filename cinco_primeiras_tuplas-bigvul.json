[
    {
        "": "0",
        "Access Gained": "None",
        "Attack Origin": "Remote",
        "Authentication Required": "Single system",
        "Availability": "Partial",
        "CVE ID": "CVE-2015-8467",
        "CVE Page": "https://www.cvedetails.com/cve/CVE-2015-8467/",
        "CWE ID": "CWE-264",
        "Complexity": "Medium",
        "Confidentiality": "Partial",
        "Integrity": "Partial",
        "Known Exploits": "",
        "Publish Date": "2015-12-29",
        "Score": "6.0",
        "Summary": "The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",
        "Update Date": "2016-12-30",
        "Vulnerability Classification": "Bypass",
        "add_lines": "0",
        "codeLink": "https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_id": "b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_message": "",
        "del_lines": "0",
        "file_name": "",
        "files_changed": "",
        "func_after": "static bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n",
        "func_before": "static bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n",
        "lang": "C",
        "lines_after": "",
        "lines_before": "",
        "parentID": "a819d2b440aafa3138d95ff6e8b824da885a70e9",
        "patch": "@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n        struct security_token *user_token;\n        struct security_descriptor *domain_sd;\n        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n        const struct uac_to_guid {\n                uint32_t uac;\n+               uint32_t priv_to_change_from;\n                const char *oid;\n                const char *guid;\n                enum sec_privilege privilege;\n                bool delete_is_privileged;\n+               bool admin_required;\n                const char *error_string;\n        } map[] = {\n                {\n@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                        .guid = GUID_DRS_DS_INSTALL_REPLICA,\n                        .error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n                },\n+               {\n+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,\n+                       .error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n+               {\n+                       .uac = UF_NORMAL_ACCOUNT,\n+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n                {\n                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                return ldb_module_operr(ac->module);\n        }\n \n-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n+       ret = dsdb_get_sd_from_ldb_message(ldb,\n                                           ac, res->msgs[0], &domain_sd);\n \n        if (ret != LDB_SUCCESS) {\n@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                                if (have_priv == false) {\n                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n                                }\n-                       } else {\n+                       } else if (map[i].priv_to_change_from & user_account_control_old) {\n+                               bool is_admin = security_token_has_builtin_administrators(user_token);\n+                               if (is_admin == false) {\n+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n+                               }\n+                       } else if (map[i].guid) {\n                                ret = acl_check_extended_right(ac, domain_sd,\n                                                               user_token,\n                                                               map[i].guid,\n                                                               SEC_ADS_CONTROL_ACCESS,\n                                                               sid);\n+                       } else {\n+                               ret = LDB_SUCCESS;\n                        }\n                        if (ret != LDB_SUCCESS) {\n                                break;",
        "project": "samba",
        "project_after": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd",
        "project_before": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98",
        "vul": "0",
        "vul_func_with_fix": "static bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n"
    },
    {
        "": "1",
        "Access Gained": "None",
        "Attack Origin": "Remote",
        "Authentication Required": "Single system",
        "Availability": "Partial",
        "CVE ID": "CVE-2015-8467",
        "CVE Page": "https://www.cvedetails.com/cve/CVE-2015-8467/",
        "CWE ID": "CWE-264",
        "Complexity": "Medium",
        "Confidentiality": "Partial",
        "Integrity": "Partial",
        "Known Exploits": "",
        "Publish Date": "2015-12-29",
        "Score": "6.0",
        "Summary": "The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",
        "Update Date": "2016-12-30",
        "Vulnerability Classification": "Bypass",
        "add_lines": "0",
        "codeLink": "https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_id": "b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_message": "",
        "del_lines": "0",
        "file_name": "",
        "files_changed": "",
        "func_after": "static int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n",
        "func_before": "static int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n",
        "lang": "C",
        "lines_after": "",
        "lines_before": "",
        "parentID": "a819d2b440aafa3138d95ff6e8b824da885a70e9",
        "patch": "@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n        struct security_token *user_token;\n        struct security_descriptor *domain_sd;\n        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n        const struct uac_to_guid {\n                uint32_t uac;\n+               uint32_t priv_to_change_from;\n                const char *oid;\n                const char *guid;\n                enum sec_privilege privilege;\n                bool delete_is_privileged;\n+               bool admin_required;\n                const char *error_string;\n        } map[] = {\n                {\n@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                        .guid = GUID_DRS_DS_INSTALL_REPLICA,\n                        .error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n                },\n+               {\n+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,\n+                       .error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n+               {\n+                       .uac = UF_NORMAL_ACCOUNT,\n+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n                {\n                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                return ldb_module_operr(ac->module);\n        }\n \n-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n+       ret = dsdb_get_sd_from_ldb_message(ldb,\n                                           ac, res->msgs[0], &domain_sd);\n \n        if (ret != LDB_SUCCESS) {\n@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                                if (have_priv == false) {\n                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n                                }\n-                       } else {\n+                       } else if (map[i].priv_to_change_from & user_account_control_old) {\n+                               bool is_admin = security_token_has_builtin_administrators(user_token);\n+                               if (is_admin == false) {\n+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n+                               }\n+                       } else if (map[i].guid) {\n                                ret = acl_check_extended_right(ac, domain_sd,\n                                                               user_token,\n                                                               map[i].guid,\n                                                               SEC_ADS_CONTROL_ACCESS,\n                                                               sid);\n+                       } else {\n+                               ret = LDB_SUCCESS;\n                        }\n                        if (ret != LDB_SUCCESS) {\n                                break;",
        "project": "samba",
        "project_after": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd",
        "project_before": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98",
        "vul": "0",
        "vul_func_with_fix": "static int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n"
    },
    {
        "": "2",
        "Access Gained": "None",
        "Attack Origin": "Remote",
        "Authentication Required": "Single system",
        "Availability": "Partial",
        "CVE ID": "CVE-2015-8467",
        "CVE Page": "https://www.cvedetails.com/cve/CVE-2015-8467/",
        "CWE ID": "CWE-264",
        "Complexity": "Medium",
        "Confidentiality": "Partial",
        "Integrity": "Partial",
        "Known Exploits": "",
        "Publish Date": "2015-12-29",
        "Score": "6.0",
        "Summary": "The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",
        "Update Date": "2016-12-30",
        "Vulnerability Classification": "Bypass",
        "add_lines": "0",
        "codeLink": "https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_id": "b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_message": "",
        "del_lines": "0",
        "file_name": "",
        "files_changed": "",
        "func_after": "static int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t/* The caller may wish to get controls back from the add */\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n",
        "func_before": "static int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t/* The caller may wish to get controls back from the add */\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n",
        "lang": "C",
        "lines_after": "",
        "lines_before": "",
        "parentID": "a819d2b440aafa3138d95ff6e8b824da885a70e9",
        "patch": "@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n        struct security_token *user_token;\n        struct security_descriptor *domain_sd;\n        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n        const struct uac_to_guid {\n                uint32_t uac;\n+               uint32_t priv_to_change_from;\n                const char *oid;\n                const char *guid;\n                enum sec_privilege privilege;\n                bool delete_is_privileged;\n+               bool admin_required;\n                const char *error_string;\n        } map[] = {\n                {\n@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                        .guid = GUID_DRS_DS_INSTALL_REPLICA,\n                        .error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n                },\n+               {\n+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,\n+                       .error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n+               {\n+                       .uac = UF_NORMAL_ACCOUNT,\n+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n                {\n                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                return ldb_module_operr(ac->module);\n        }\n \n-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n+       ret = dsdb_get_sd_from_ldb_message(ldb,\n                                           ac, res->msgs[0], &domain_sd);\n \n        if (ret != LDB_SUCCESS) {\n@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                                if (have_priv == false) {\n                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n                                }\n-                       } else {\n+                       } else if (map[i].priv_to_change_from & user_account_control_old) {\n+                               bool is_admin = security_token_has_builtin_administrators(user_token);\n+                               if (is_admin == false) {\n+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n+                               }\n+                       } else if (map[i].guid) {\n                                ret = acl_check_extended_right(ac, domain_sd,\n                                                               user_token,\n                                                               map[i].guid,\n                                                               SEC_ADS_CONTROL_ACCESS,\n                                                               sid);\n+                       } else {\n+                               ret = LDB_SUCCESS;\n                        }\n                        if (ret != LDB_SUCCESS) {\n                                break;",
        "project": "samba",
        "project_after": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd",
        "project_before": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98",
        "vul": "0",
        "vul_func_with_fix": "static int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t/* The caller may wish to get controls back from the add */\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n"
    },
    {
        "": "3",
        "Access Gained": "None",
        "Attack Origin": "Remote",
        "Authentication Required": "Single system",
        "Availability": "Partial",
        "CVE ID": "CVE-2015-8467",
        "CVE Page": "https://www.cvedetails.com/cve/CVE-2015-8467/",
        "CWE ID": "CWE-264",
        "Complexity": "Medium",
        "Confidentiality": "Partial",
        "Integrity": "Partial",
        "Known Exploits": "",
        "Publish Date": "2015-12-29",
        "Score": "6.0",
        "Summary": "The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",
        "Update Date": "2016-12-30",
        "Vulnerability Classification": "Bypass",
        "add_lines": "0",
        "codeLink": "https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_id": "b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_message": "",
        "del_lines": "0",
        "file_name": "",
        "files_changed": "",
        "func_after": "static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* msDS-IntId is handled by system and should never be\n\t * passed by clients */\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* do not generate msDS-IntId if Relax control is passed */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check Functional Level */\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check systemFlags for SCHEMA_BASE_OBJECT flag */\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range */\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tmsds_intid_struct->usn = schema->loaded_usn;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t/* probe id values until unique one is found */\n\tdo {\n\t\tuint64_t current_usn;\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t/*\n\t\t * Alternative strategy to a costly (even indexed search) to the\n\t\t * database.\n\t\t * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because\n\t\t * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t * If so generate another random value.\n\t\t * If not check if the highest USN in the database for the schema partition is the\n\t\t * one that we know.\n\t\t * If so it means that's only this ldb context that is touching the schema in the database.\n\t\t * If not it means that's someone else has modified the database while we are doing our changes too\n\t\t * (this case should be very bery rare) in order to be sure do the search in the database.\n\t\t */\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = dsdb_module_load_partition_usn(ac->module, schema_dn,\n\t\t\t\t\t\t     &current_usn, NULL, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for schema USN failed: %s\\n\",\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\n\t\t/* current_usn can be lesser than msds_intid_struct-> if there is\n\t\t * uncommited changes.\n\t\t */\n\t\tif (current_usn > msds_intid_struct->usn) {\n\t\t\t/* oups something has changed, someone/something\n\t\t\t * else is modifying or has modified the schema\n\t\t\t * we'd better check this intid is the database directly\n\t\t\t */\n\n\t\t\tDEBUG(2, (\"Schema has changed, searching the database for the unicity of %d\\n\",\n\t\t\t\t\tmsds_intid));\n\n\t\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t\t&ldb_res,\n\t\t\t\t\t\tschema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t\tDSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t\tac->req,\n\t\t\t\t\t\t\"(msDS-IntId=%d)\", msds_intid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t\t__location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t\tmsds_intid,\n\t\t\t\t\tldb_errstring(ldb));\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\t\t\tid_exists = (ldb_res->count > 0);\n\t\t\ttalloc_free(ldb_res);\n\t\t} else {\n\t\t\tid_exists = 0;\n\t\t}\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n",
        "func_before": "static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* msDS-IntId is handled by system and should never be\n\t * passed by clients */\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* do not generate msDS-IntId if Relax control is passed */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check Functional Level */\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check systemFlags for SCHEMA_BASE_OBJECT flag */\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range */\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tmsds_intid_struct->usn = schema->loaded_usn;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t/* probe id values until unique one is found */\n\tdo {\n\t\tuint64_t current_usn;\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t/*\n\t\t * Alternative strategy to a costly (even indexed search) to the\n\t\t * database.\n\t\t * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because\n\t\t * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t * If so generate another random value.\n\t\t * If not check if the highest USN in the database for the schema partition is the\n\t\t * one that we know.\n\t\t * If so it means that's only this ldb context that is touching the schema in the database.\n\t\t * If not it means that's someone else has modified the database while we are doing our changes too\n\t\t * (this case should be very bery rare) in order to be sure do the search in the database.\n\t\t */\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = dsdb_module_load_partition_usn(ac->module, schema_dn,\n\t\t\t\t\t\t     &current_usn, NULL, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for schema USN failed: %s\\n\",\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\n\t\t/* current_usn can be lesser than msds_intid_struct-> if there is\n\t\t * uncommited changes.\n\t\t */\n\t\tif (current_usn > msds_intid_struct->usn) {\n\t\t\t/* oups something has changed, someone/something\n\t\t\t * else is modifying or has modified the schema\n\t\t\t * we'd better check this intid is the database directly\n\t\t\t */\n\n\t\t\tDEBUG(2, (\"Schema has changed, searching the database for the unicity of %d\\n\",\n\t\t\t\t\tmsds_intid));\n\n\t\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t\t&ldb_res,\n\t\t\t\t\t\tschema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t\tDSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t\tac->req,\n\t\t\t\t\t\t\"(msDS-IntId=%d)\", msds_intid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t\t__location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t\tmsds_intid,\n\t\t\t\t\tldb_errstring(ldb));\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\t\t\tid_exists = (ldb_res->count > 0);\n\t\t\ttalloc_free(ldb_res);\n\t\t} else {\n\t\t\tid_exists = 0;\n\t\t}\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n",
        "lang": "C",
        "lines_after": "",
        "lines_before": "",
        "parentID": "a819d2b440aafa3138d95ff6e8b824da885a70e9",
        "patch": "@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n        struct security_token *user_token;\n        struct security_descriptor *domain_sd;\n        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n        const struct uac_to_guid {\n                uint32_t uac;\n+               uint32_t priv_to_change_from;\n                const char *oid;\n                const char *guid;\n                enum sec_privilege privilege;\n                bool delete_is_privileged;\n+               bool admin_required;\n                const char *error_string;\n        } map[] = {\n                {\n@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                        .guid = GUID_DRS_DS_INSTALL_REPLICA,\n                        .error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n                },\n+               {\n+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,\n+                       .error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n+               {\n+                       .uac = UF_NORMAL_ACCOUNT,\n+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n                {\n                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                return ldb_module_operr(ac->module);\n        }\n \n-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n+       ret = dsdb_get_sd_from_ldb_message(ldb,\n                                           ac, res->msgs[0], &domain_sd);\n \n        if (ret != LDB_SUCCESS) {\n@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                                if (have_priv == false) {\n                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n                                }\n-                       } else {\n+                       } else if (map[i].priv_to_change_from & user_account_control_old) {\n+                               bool is_admin = security_token_has_builtin_administrators(user_token);\n+                               if (is_admin == false) {\n+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n+                               }\n+                       } else if (map[i].guid) {\n                                ret = acl_check_extended_right(ac, domain_sd,\n                                                               user_token,\n                                                               map[i].guid,\n                                                               SEC_ADS_CONTROL_ACCESS,\n                                                               sid);\n+                       } else {\n+                               ret = LDB_SUCCESS;\n                        }\n                        if (ret != LDB_SUCCESS) {\n                                break;",
        "project": "samba",
        "project_after": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd",
        "project_before": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98",
        "vul": "0",
        "vul_func_with_fix": "static int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* msDS-IntId is handled by system and should never be\n\t * passed by clients */\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* do not generate msDS-IntId if Relax control is passed */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check Functional Level */\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check systemFlags for SCHEMA_BASE_OBJECT flag */\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range */\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tmsds_intid_struct->usn = schema->loaded_usn;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t/* probe id values until unique one is found */\n\tdo {\n\t\tuint64_t current_usn;\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t/*\n\t\t * Alternative strategy to a costly (even indexed search) to the\n\t\t * database.\n\t\t * We search in the schema if we have already this intid (using dsdb_attribute_by_attributeID_id because\n\t\t * in the range 0x80000000 0xBFFFFFFFF, attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t * If so generate another random value.\n\t\t * If not check if the highest USN in the database for the schema partition is the\n\t\t * one that we know.\n\t\t * If so it means that's only this ldb context that is touching the schema in the database.\n\t\t * If not it means that's someone else has modified the database while we are doing our changes too\n\t\t * (this case should be very bery rare) in order to be sure do the search in the database.\n\t\t */\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = dsdb_module_load_partition_usn(ac->module, schema_dn,\n\t\t\t\t\t\t     &current_usn, NULL, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for schema USN failed: %s\\n\",\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\n\t\t/* current_usn can be lesser than msds_intid_struct-> if there is\n\t\t * uncommited changes.\n\t\t */\n\t\tif (current_usn > msds_intid_struct->usn) {\n\t\t\t/* oups something has changed, someone/something\n\t\t\t * else is modifying or has modified the schema\n\t\t\t * we'd better check this intid is the database directly\n\t\t\t */\n\n\t\t\tDEBUG(2, (\"Schema has changed, searching the database for the unicity of %d\\n\",\n\t\t\t\t\tmsds_intid));\n\n\t\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t\t&ldb_res,\n\t\t\t\t\t\tschema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t\tDSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t\tac->req,\n\t\t\t\t\t\t\"(msDS-IntId=%d)\", msds_intid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t\t__location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t\tmsds_intid,\n\t\t\t\t\tldb_errstring(ldb));\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\t\t\tid_exists = (ldb_res->count > 0);\n\t\t\ttalloc_free(ldb_res);\n\t\t} else {\n\t\t\tid_exists = 0;\n\t\t}\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n"
    },
    {
        "": "4",
        "Access Gained": "None",
        "Attack Origin": "Remote",
        "Authentication Required": "Single system",
        "Availability": "Partial",
        "CVE ID": "CVE-2015-8467",
        "CVE Page": "https://www.cvedetails.com/cve/CVE-2015-8467/",
        "CWE ID": "CWE-264",
        "Complexity": "Medium",
        "Confidentiality": "Partial",
        "Integrity": "Partial",
        "Known Exploits": "",
        "Publish Date": "2015-12-29",
        "Score": "6.0",
        "Summary": "The samldb_check_user_account_control_acl function in dsdb/samdb/ldb_modules/samldb.c in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3 does not properly check for administrative privileges during creation of machine accounts, which allows remote authenticated users to bypass intended access restrictions by leveraging the existence of a domain with both a Samba DC and a Windows DC, a similar issue to CVE-2015-2535.",
        "Update Date": "2016-12-30",
        "Vulnerability Classification": "Bypass",
        "add_lines": "0",
        "codeLink": "https://git.samba.org/?p=samba.git;a=commit;h=b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_id": "b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d",
        "commit_message": "",
        "del_lines": "0",
        "file_name": "",
        "files_changed": "",
        "func_after": "static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n",
        "func_before": "static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n",
        "lang": "C",
        "lines_after": "",
        "lines_before": "",
        "parentID": "a819d2b440aafa3138d95ff6e8b824da885a70e9",
        "patch": "@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n        struct security_token *user_token;\n        struct security_descriptor *domain_sd;\n        struct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n+       struct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n        const struct uac_to_guid {\n                uint32_t uac;\n+               uint32_t priv_to_change_from;\n                const char *oid;\n                const char *guid;\n                enum sec_privilege privilege;\n                bool delete_is_privileged;\n+               bool admin_required;\n                const char *error_string;\n        } map[] = {\n                {\n@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                        .guid = GUID_DRS_DS_INSTALL_REPLICA,\n                        .error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n                },\n+               {\n+                       .uac = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .priv_to_change_from = UF_NORMAL_ACCOUNT,\n+                       .error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n+               {\n+                       .uac = UF_NORMAL_ACCOUNT,\n+                       .priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n+                       .error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n+               },\n                {\n                        .uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n                        .oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                return ldb_module_operr(ac->module);\n        }\n \n-       ret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n+       ret = dsdb_get_sd_from_ldb_message(ldb,\n                                           ac, res->msgs[0], &domain_sd);\n \n        if (ret != LDB_SUCCESS) {\n@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n                                if (have_priv == false) {\n                                        ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n                                }\n-                       } else {\n+                       } else if (map[i].priv_to_change_from & user_account_control_old) {\n+                               bool is_admin = security_token_has_builtin_administrators(user_token);\n+                               if (is_admin == false) {\n+                                       ret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n+                               }\n+                       } else if (map[i].guid) {\n                                ret = acl_check_extended_right(ac, domain_sd,\n                                                               user_token,\n                                                               map[i].guid,\n                                                               SEC_ADS_CONTROL_ACCESS,\n                                                               sid);\n+                       } else {\n+                               ret = LDB_SUCCESS;\n                        }\n                        if (ret != LDB_SUCCESS) {\n                                break;",
        "project": "samba",
        "project_after": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=df285d91485ba8393d368ddf6328957d26ff57dd;hb=df285d91485ba8393d368ddf6328957d26ff57dd",
        "project_before": "https://git.samba.org/?p=samba.git;a=blob;f=source4/dsdb/samdb/ldb_modules/samldb.c;h=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98;hb=e3a7db27aa9c4b2ea5fba2f4f91b87d90c502e98",
        "vul": "0",
        "vul_func_with_fix": "static int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n"
    }
]